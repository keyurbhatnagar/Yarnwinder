/*     Simple Stepper Motor Control Exaple Code
 *      
 *  by Dejan Nedelkovski, www.HowToMechatronics.com
 *  
 */


#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#define OLED_RESET 4
Adafruit_SSD1306 display(OLED_RESET);

#define NUMFLAKES 10
#define XPOS 0
#define YPOS 1
#define DELTAY 2


#define LOGO16_GLCD_HEIGHT 16 
#define LOGO16_GLCD_WIDTH  16 

const unsigned char PROGMEM logoname [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xE0,
0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x80, 0x03, 0xF0, 0x00, 0x3D, 0x80, 0x00, 0x00,
0x00, 0x00, 0x0D, 0x80, 0x07, 0xF0, 0x00, 0x6F, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x09, 0x80, 0x06,
0x70, 0x00, 0x67, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x07, 0xE0, 0x00, 0x3F, 0x1A, 0x00,
0x00, 0x00, 0x00, 0x18, 0x00, 0x07, 0x70, 0x00, 0x0E, 0x1E, 0x00, 0x00, 0xC0, 0x00, 0x18, 0x6D,
0x8F, 0x34, 0x20, 0x02, 0x16, 0x00, 0x00, 0xC0, 0x10, 0x1E, 0xFF, 0x0F, 0xF6, 0x64, 0x02, 0x14,
0x00, 0x0C, 0xBE, 0x78, 0x38, 0x96, 0x08, 0x06, 0x65, 0x02, 0x1C, 0xF7, 0xFE, 0xFF, 0x6C, 0x7A,
0xD4, 0x0B, 0xE4, 0x65, 0x02, 0x19, 0x97, 0x76, 0xBB, 0xCC, 0x7A, 0xDC, 0x0F, 0x74, 0xE7, 0x02,
0x19, 0x16, 0x67, 0xB3, 0xD8, 0x52, 0x3C, 0x1E, 0x1C, 0xEF, 0x03, 0x73, 0x14, 0x67, 0xB3, 0xB8,
0xD3, 0x6C, 0x1F, 0xF7, 0xFB, 0x01, 0xF3, 0x34, 0x67, 0xA3, 0xF8, 0x93, 0xE8, 0x19, 0xE3, 0x39,
0x78, 0x13, 0x74, 0x47, 0xA2, 0xF8, 0x90, 0x00, 0x00, 0x00, 0x00, 0x78, 0x33, 0xDC, 0x45, 0xA0,
0x18, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x58, 0x30, 0x00, 0x00, 0x01, 0xCC, 0xB0, 0x00, 0x00, 0x00,
0x00, 0x60, 0x60, 0x00, 0x00, 0x03, 0xCC, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x70, 0xC0, 0x00, 0x00,
0x02, 0x0C, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x80, 0x00, 0x00, 0x03, 0x18, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

const unsigned char PROGMEM logo [] = {
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x7C, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xE4, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x01, 0xC0, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0xFF, 0x87, 0x07, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x03, 0xFF, 0xEE, 0x3F, 0xB0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00,
0x00, 0x0F, 0xEA, 0xF9, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x7C, 0x00, 0x00,
0x00, 0x1E, 0xEE, 0xBF, 0xC1, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x7E, 0x00, 0x00,
0x00, 0x3B, 0x6E, 0xFE, 0x07, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x01, 0xB0, 0x00, 0xFE, 0x00, 0x00,
0x00, 0x7D, 0xFE, 0xDE, 0x06, 0xD8, 0xC0, 0x00, 0x00, 0x00, 0x01, 0xB0, 0x00, 0xDE, 0x00, 0x00,
0x00, 0x76, 0xFE, 0xEF, 0x06, 0x71, 0xE0, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xFC, 0x00, 0x00,
0x00, 0xDB, 0x7F, 0xBF, 0x03, 0xF1, 0xE0, 0x00, 0x10, 0x00, 0x03, 0x00, 0x00, 0xFE, 0x00, 0x00,
0x00, 0xED, 0xFF, 0xB7, 0x81, 0xE1, 0x60, 0x00, 0x1C, 0x00, 0x03, 0x0D, 0xB1, 0xE6, 0x8C, 0x80,
0x00, 0xBE, 0xDF, 0xD7, 0x80, 0x61, 0x60, 0x00, 0x1C, 0x03, 0x03, 0xFF, 0xF1, 0xFE, 0xCD, 0x9C,
0x01, 0xFB, 0xF5, 0xDD, 0x80, 0x61, 0xC4, 0x15, 0x8E, 0xE7, 0x87, 0x12, 0xC3, 0x01, 0xCD, 0xBE,
0x0F, 0xFD, 0xBD, 0xF3, 0x80, 0x61, 0xDF, 0xFF, 0xDF, 0xED, 0x87, 0x7A, 0x83, 0x7D, 0x9D, 0xE6,
0x7F, 0xDF, 0xAF, 0xCE, 0x80, 0x61, 0x9B, 0x66, 0x5B, 0x69, 0x8F, 0x7B, 0x81, 0xFF, 0x99, 0xFC,
0x71, 0xE3, 0x7B, 0x3B, 0x80, 0x63, 0xB3, 0x46, 0x5B, 0x7B, 0x8B, 0x47, 0x83, 0xC3, 0x99, 0x58,
0x01, 0xBE, 0xDF, 0xE7, 0x80, 0x37, 0x33, 0xC4, 0x5E, 0x7F, 0x9B, 0x6D, 0x83, 0xFE, 0xFF, 0x60,
0x01, 0xED, 0xF7, 0xBF, 0x80, 0x3F, 0x33, 0xCC, 0xD6, 0x7F, 0x9B, 0x7D, 0x03, 0x3C, 0xEE, 0x7C,
0x03, 0xFB, 0xFD, 0xFF, 0x87, 0x83, 0x3F, 0xCC, 0xD6, 0x6F, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x1C,
0x07, 0xF7, 0xEF, 0xBF, 0x05, 0x83, 0x3F, 0xCC, 0xD6, 0x23, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00,
0x1C, 0xDD, 0xDF, 0xBF, 0x05, 0x83, 0x00, 0x00, 0x00, 0x39, 0xB6, 0x00, 0x00, 0x00, 0x00, 0x00,
0x38, 0x7B, 0xF7, 0xAE, 0x06, 0x06, 0x00, 0x00, 0x00, 0x79, 0x9E, 0x00, 0x00, 0x00, 0x00, 0x00,
0x70, 0x3E, 0xF5, 0xAE, 0x07, 0xFC, 0x00, 0x00, 0x00, 0x61, 0x9C, 0x00, 0x00, 0x00, 0x00, 0x00,
0xC0, 0x3F, 0xFD, 0x7C, 0x03, 0xF8, 0x00, 0x00, 0x00, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x80, 0x1F, 0xFF, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x1F, 0xBF, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x33, 0xFF, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x30, 0xFF, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x18, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x1F, 0xFF, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x0F, 0xF0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


#if (SSD1306_LCDHEIGHT != 64)
#error("Height incorrect, please fix Adafruit_SSD1306.h!");
#endif

#define encoder0PinA  2
#define encoder0PinB  3
#define buzzerPin 5
int sensorPin = 0;
char number[4];
static int pinA = 2; // Our first hardware interrupt pin is digital pin 2
static int pinB = 3; // Our second hardware interrupt pin is digital pin 3
static int pinSwitch = 12;
volatile byte aFlag = 0; // let's us know when we're expecting a rising edge on pinA to signal that the encoder has arrived at a detent
volatile byte bFlag = 0; // let's us know when we're expecting a rising edge on pinB to signal that the encoder has arrived at a detent (opposite direction to when aFlag is set)
volatile byte encoder0Pos = 1, lastPosition = 1; //this variable stores our current value of encoder position. Change to int or uin16_t instead of byte if you want to record a larger range than 0-255
volatile byte oldEncPos = 0; //stores the last encoder position value so we can compare to the current reading and see if it has changed (so we know when to print to the serial monitor)
volatile byte reading = 0; //somewhere to store the direct values we read from our interrupt pins before checking to see if we have moved a whole detent
bool bEnable = false;
int lastPinSwitchState = LOW;

int PUL=7; //define Pulse pin
int DIR=6; //define Direction pin
int ENA=5; //define Enable Pin

// Defines pins numbers
const int stepPin = 4;
const int dirPin = 5; 

int customDelay,customDelayMapped; // Defines variables
 
void setup() {
  // Sets the two pins as Outputs
  //pinMode(stepPin,OUTPUT);
  //pinMode(dirPin,OUTPUT);
  //digitalWrite(dirPin,HIGH); //Enables the motor to move in a particular direction

  //Motor Controller
  pinMode (PUL, OUTPUT);
  pinMode (DIR, OUTPUT);
  pinMode (ENA, OUTPUT);
  
  digitalWrite(DIR,LOW);
  //digitalWrite(ENA,HIGH);

  pinMode(pinA, INPUT_PULLUP); // set pinA as an input, pulled HIGH to the logic voltage (5V or 3.3V for most cases)
  pinMode(pinB, INPUT_PULLUP); // set pinB as an input, pulled HIGH to the logic voltage (5V or 3.3V for most cases)
  attachInterrupt(0,PinA,RISING); // set an interrupt on PinA, looking for a rising edge signal and executing the "PinA" Interrupt Service Routine (below)
  attachInterrupt(1,PinB,RISING); // set an interrupt on PinB, looking for a rising edge signal and executing the "PinB" Interrupt Service Routine (below)
  pinMode(pinSwitch, INPUT);
  digitalWrite(pinSwitch, HIGH);
  
  Serial.begin (9600);
  Serial.println("start");                // a personal quirk

  // by default, we'll generate the high voltage from the 3.3v line internally! (neat!)
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);  // initialize with the I2C addr 0x3D (for the 128x64)
  // init done
  
  
  display.clearDisplay();

  for(int i=45; i>=-16; i-- )
  {
    display.clearDisplay();
  // miniature bitmap display
    display.drawBitmap(0, i,  logo, 128, 55, 1);
    display.display();
    delay(1);
  }

  delay(500);
  Serial.println("logo done");                // a personal quirk

  display.clearDisplay();
  
  display.drawBitmap(0, -16,  logo, 128, 55, 1);
  display.display();
  display.setTextSize(2);
  display.setTextColor(WHITE);
  display.setCursor(12,40);
  display.println("Motor OFF");
  display.setTextSize(1);
  display.println(" Press knob to start.");
  display.display();
  
}

void PinA(){
  Serial.println("PinA");
  cli(); //stop interrupts happening before we read pin values
  reading = PIND & 0xC; // read all eight pin values then strip away all but pinA and pinB's values
  if(reading == B00001100 && aFlag) { //check that we have both pins at detent (HIGH) and that we are expecting detent on this pin's rising edge
    incrementPos(); //decrement the encoder's position count
    bFlag = 0; //reset flags for the next turn
    aFlag = 0; //reset flags for the next turn
  }
  else if (reading == B00000100) bFlag = 1; //signal that we're expecting pinB to signal the transition to detent from free rotation
  sei(); //restart interrupts
}

void PinB(){
  Serial.println("PinB");
  cli(); //stop interrupts happening before we read pin values
  reading = PIND & 0xC; //read all eight pin values then strip away all but pinA and pinB's values
  if (reading == B00001100 && bFlag) { //check that we have both pins at detent (HIGH) and that we are expecting detent on this pin's rising edge
    decrementPos(); //increment the encoder's position count
    bFlag = 0; //reset flags for the next turn
    aFlag = 0; //reset flags for the next turn
  }
  else if (reading == B00001000) aFlag = 1; //signal that we're expecting pinA to signal the transition to detent from free rotation
  sei(); //restart interrupts
}

void testdrawchar(int count) {
  memset(number, 0, sizeof(number));
  sprintf(number,"%d", count);
  display.setTextSize(1);
  display.setCursor(1,40);
  display.println("Speed");
  display.setTextSize(2);
  display.setTextColor(WHITE);
  if( strlen(number) == 1 )
  {
    display.setCursor(11,50);
  }
//  else if( strlen(number) == 2 )
//  {
//    display.setCursor(98,55);
//  }
//  else
//  {
//    display.setCursor(96,42);
//  }
  for(int i = 0;i<4;i++)
  {
    if( number[i] != 0 )
    {
      display.write(number[i]);
    }
  }
  display.display();
}

void testdrawrect(int i) {
  display.clearDisplay();
  display.drawBitmap(0, -16,  logo, 128, 55, 1);
  for(int n = 0; n < 5; n++)
  {
    display.drawRect(34+n*18, 51 - n*5, 16, 13 + n*5, WHITE);
  }

  for(int k = 0; k < i; k++)
  {
    display.fillRect(36+k*18, 53 - k*5, 12, 9 + k*5, WHITE);
  }
  
  display.display();

  testdrawchar(i);
  
  delay(1);
}

void loop() {

  int currentPinState = digitalRead(pinSwitch);
  if(currentPinState == LOW && currentPinState != lastPinSwitchState )//if button pull down
  {
    bEnable = !bEnable;
    if( !bEnable )
    {
      encoder0Pos = 1;    
      display.clearDisplay(); 
      display.drawBitmap(0, -16,  logo, 128, 55, 1);
      display.display();
      display.setTextSize(2);
      display.setTextColor(WHITE);
      display.setCursor(12,40);
      display.println("Motor OFF");
      display.setTextSize(1);
      display.println(" Press knob to start.");
      display.display();
      digitalWrite(ENA,LOW);
    }
    else
    {
      testdrawrect(encoder0Pos);
      digitalWrite(ENA,HIGH);
    }
    Serial.print("Motor Enabled : ");
    Serial.println(bEnable);
    lastPinSwitchState = currentPinState;
  }
  else if( currentPinState == HIGH )
  {
    lastPinSwitchState = currentPinState;
  }

  if( bEnable )
  {
    if( lastPosition != encoder0Pos  )
    {
      Serial.println(encoder0Pos);
      testdrawrect(encoder0Pos);
      lastPosition = encoder0Pos;
    }
    
    customDelayMapped = speedUp(); // Gets custom delay values from the custom speedUp function
    // Makes pules with custom delay, depending on the Potentiometer, from which the speed of the motor depends
    digitalWrite(PUL, HIGH);
    delayMicroseconds(customDelayMapped);
    digitalWrite(PUL, LOW);
    delayMicroseconds(customDelayMapped);
  }
}

void decrementPos()
{
  if( encoder0Pos > 1 )
  {
    encoder0Pos = encoder0Pos - 1;
  }
}

void incrementPos()
{
  if( encoder0Pos < 5 )
  {
    encoder0Pos = encoder0Pos + 1;
  }
}

// Function for reading the Potentiometer
int speedUp() {
  int newCustom = map(encoder0Pos, 1, 5, 100,13); // Convrests the read values of the potentiometer from 0 to 1023 into desireded delay values (300 to 4000)
  return newCustom;  
}
